#ifndef COMPONENT_SYSTEM_H__
#define COMPONENT_SYSTEM_H__

#include "EntityManager.h"
#include "Component.h"
#include "messaging.h"
#include MAP_TYPE_HEADER
#include <string>
#include "ComponentStore.h"
#include "Logging.h"

class SystemManager;
class ComponentSystem;


class ComponentSystem
{
public:
    ComponentSystem()
    : componentStore(NULL)
    , destroyEntity_r(NULL)
    , componentUpdated_r(NULL)
    , requests(NULL)
    , curPlayerID(0)
    {}

    virtual ~ComponentSystem()
    {
        ASSERT(componentStore != NULL, "Not a valid component system! CreateComponentStore wasn't overridden!");
        delete componentStore;
        free(requests);
        requests = NULL;
    }

    // Add is called during load time and run time, in the future we may want to add a isRunTime flag
    virtual void ComponentAdded(EntityID entityID, Component* component);
    virtual void ComponentRemoved(EntityID entityID, Component* removedComponent);

    // If an entity is destroyed, it will also call ComponentRemoved, so use
    //      entityDestroyed purely for zeroing references
    virtual void EntityDestroyed(EntityID entityID);

    virtual void EntityRefRemoved(EntityID referringID, EntityID referredID);


    // Autogenerated by python
    virtual void CreateBindSockets();
    virtual void CreateConnectSockets();
    virtual void StripEntityReferences(EntityID entityID);
    virtual void GetFriends(SystemManager* interface);
    virtual void CheckSocketsAndDestroy();

    virtual int GetNumberReceiveSockets();
    virtual zmq_pollitem_t* FillPollInformation(zmq_pollitem_t* pollItems);
    virtual zmq_pollitem_t* ProcessEvents(zmq_pollitem_t* pollItems);

    std::string GetSystemMessageName(const char* baseMessageName);
    virtual std::string SystemName() = 0;

    std::string ComponentName()
    {
        CreateComponentStoreIfNeeded();
        return componentStore->GetComponentName();
    }
    
    virtual void init(SystemManager* sysManager);

    void ClearStore();
    void AddComponentToStore(EntityID entityID, std::string data, unsigned long timestamp);
    bool RemoveComponentFromStore(EntityID entityID, unsigned long timestamp);
    MAP_TYPE<EntityID, std::string> GetAllComponentsDataFromStore();

    template <class componentType>
    MAP_TYPE<EntityID, componentType*>& GetComponentMap()
    {
        CreateComponentStoreIfNeeded();
        return ((ComponentStore<componentType>*) componentStore)->components;
    }

protected:
    void CreateComponentStoreIfNeeded()
    {
        if ( componentStore == NULL )
            componentStore = CreateComponentStore();
    }

    virtual ComponentStore_* CreateComponentStore() = 0;

    ComponentStore_* componentStore;

    bool didMessage;

    LogStream logError;
    LogStream logGameplay;
    LogStream logWarning;
    LogStream logDebug;
    LogStream logInfo;

    EntityID* requests;

    EntityID curPlayerID;
private:
    bool isInited;

    void* newPlayer_r;
    void* destroyEntity_r;
    void* componentUpdated_r;
};

#define GET_COMPONENTS(componentType) CreateComponentStoreIfNeeded(); MAP_TYPE<EntityID, componentType*>& components = GetComponentMap<componentType>();
#define ITERATE_THROUGH_COMPONENTS_START(componentType) CreateComponentStoreIfNeeded(); MAP_TYPE<EntityID, componentType*>& components = GetComponentMap<componentType>(); for( MAP_TYPE<EntityID, componentType*>::iterator i = components.begin(); i != components.end(); ++i ) { const EntityID& entityID = (*i).first; componentType*& comp = (*i).second;
#define ITERATE_THROUGH_COMPONENTS_END }
#define PROVIDE_ENTITY_INFO_START(componentType, requestVar, replyVar) GET_COMPONENTS(componentType)    /* Copy all the existing entiyinfo messages into the reply */    google::protobuf::RepeatedPtrField<EntityInfo::EntityInfo>* entities = replyVar.mutable_entities();    entities->CopyFrom(requestVar.entities());    /* Add any from the enityID list */    const google::protobuf::RepeatedField<google::protobuf::uint64>& entityIDs = requestVar.entityids();    for (google::protobuf::RepeatedField<google::protobuf::uint64>::const_iterator it = entityIDs.begin(); it != entityIDs.end(); ++it )    {        EntityInfo::EntityInfo* info = replyVar.add_entities();        info->set_entityid(*it);    }    /* Fill in info */    for (google::protobuf::RepeatedPtrField<EntityInfo::EntityInfo>::iterator it = entities->begin(); it != entities->end(); ++it )    {        EntityInfo::EntityInfo* entityInfo = &(*it);        EntityID entityID = (EntityID) entityInfo->entityid();        MAP_TYPE<EntityID, componentType*>::iterator compIT = components.find(entityID);        if ( compIT == components.end() )        {            continue;        }        componentType* comp = (*compIT).second;

#define PROVIDE_ENTITY_INFO_END }


#endif // COMPONENT_SYSTEM_H__